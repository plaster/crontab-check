#!/usr/bin/env perl
use strict;
use utf8;

use Getopt::Long qw(:config posix_default no_ignore_case gnu_compat);
use IO::File;

our $current_dispo;
our $current_line_no;
our $current_line_content;
our $current_file;

our $is_system = 1;
our $duration = 3600;

our @files;

sub error($$) {
	my $where = shift;
	my $msg = shift;
	die "*** $where Error: ${msg}\n";
}

GetOptions(
	"file=s" => \@files,
	"in=s" => sub {
		my ($k, $v) = @_;
			if ( $v =~ m/^([1-9][0-9]*)m/ ) {
				$duration = 60 * $1;
			}
			elsif ( $v =~ m/^([1-9][0-9]*)h/ ) {
				$duration = 60 * 60 * $1;
			}
			elsif ( $v =~ m/^([1-9][0-9]*)d/ ) {
				$duration = 60 * 60 * 24 * $1;
			}
			elsif ( $v =~ m/^([1-9][0-9]*)w/ ) {
				$duration = 60 * 60 * 24 * 7 * $1;
			}
			else {
				error(CommandLine => "--$k $v is invalid. allowed: [0-9][0-9]...{m|h|d|w}");
			}
	},
	"user" => sub { $is_system = 0; },
) or error(CommandLine => "invalid option.");

sub current_location() {
	my $location = '';
	if (defined($current_file) && $current_file ne '') {
		$location .= "$current_file";
	} else {
		$location .= "<Unknown>";
	}
	$location .= ":$current_line_no" if defined $current_line_no;
	$location .= ":$current_line_content" if defined ($current_line_content) && $current_line_content ne '';
	return $location;
}

sub syntax_error($) {
	my $msg = shift;
	my $location = current_location();

	error(Syntax => "$msg" . ($location eq '' ? '' : " at ${location}"));
}

# type Pat2 = ( Pat3, Maybe Int )
# data Pat3 = Number Int | Range Int Int| Asterisk
# parse2 :: String -> Pat2
sub parse2($) {
	my $pat2 = shift;

	my $pat3;
	my $step;

	if ($pat2 =~ m@(.+)/([0-9]+)@) {
		$pat3 = $1;
		$step = $2;
	} else {
		$pat3 = $pat2;
		$step = undef;
	}

	! defined($step) || $step > 1 or
		syntax_error("$step is invalid step: $pat2");

	my $n;

	if ( $pat3 eq '*' ) {
		$n = '*';
	} elsif ($pat3 =~ m/^[0-9]+$/) {
		defined($step) and
			syntax_error("step is not allowed here (must be with range or *): $pat2");
		$n = $pat3;
	} elsif ($pat3 =~ m/^([0-9]+)-([0-9]+)$/) {
		$n = +[ $1, $2 ];
		$n->[0] < $n->[1] or
			syntax_error("range is reversed: " . $n->[0] . " must be less than " . $n->[1]);
	} else {
		syntax_error("number, range or * is required, but got: $pat2");
	}

	return +[ $n, $step ];
}

# type Pat1 = [ Pat2 ]
# parse1 :: String -> Pat1
sub parse1($) {
	my $pat1 = shift;
	defined($pat1) && $pat1 ne '' or
		syntax_error("$current_dispo is missing");
	$pat1 =~ m/,$/ and
		syntax_error("trailing comma is not allowed");
	return +[ map { parse2($_) } split(m/,/, $pat1) ];
}

# type Entry = ( Pat1, Pat1, Pat1, Pat1, Pat1, String, String, String )
# parse_line :: String -> Entry
sub parse_line($) {
	local $current_line_content = shift;

	chomp $current_line_content or syntax_error("NO EOL");
	$current_line_content =~ s/^[ \t]*//;

	# blank line and comments are ignored
	return undef if $current_line_content eq '';
	return undef if $current_line_content =~ m/^#/;
	# variable line are also ignored
	return undef if $current_line_content =~ m/^[A-Za-z_]+ *=/;

	my ($min, $hour, $day, $month, $dow, $user, $cmd);
	if ($is_system) {
		($min, $hour, $day, $month, $dow, $user, $cmd) = split(m/[ \t]+/, $current_line_content, 7);
	} else {
		($min, $hour, $day, $month, $dow, $cmd) = split(m/[ \t]+/, $current_line_content, 6);
	}
	return +[
		do { local $current_dispo = 'min';       parse1($min);   },
		do { local $current_dispo = 'hour';      parse1($hour);  },
		do { local $current_dispo = 'day';       parse1($day);   },
		do { local $current_dispo = 'month';     parse1($month); },
		do { local $current_dispo = 'dayofweek'; parse1($dow);   },
		$user, $cmd, current_location() ];
}

# match2 :: (Pat2, Int) -> Boolean
sub match2($$) {
	my $pat2 = shift;
	my $time1 = shift;

	my ($pat3, $step) = @{$pat2};

	my $stepbase = 0;

	if (ref($pat3)) {
		# range
		$pat3->[0] <= $time1 && $time1 <= $pat3->[1] or return 0;
		$stepbase = $pat3->[0];
	} elsif ($pat3 eq '*') {
		# asterisk - always pass
	} else {
		# number
		$time1 == $pat3 or return 0;
	}

	# step check
	if (defined($step) && defined($stepbase)) {
		($stepbase % $step) == ($time1 % $step) || return 0;
	}

	return 1;
}

# match1 :: (Pat1, Int) -> Boolean
sub match1($$) {
	my $pat1 = shift;
	my $time1 = shift;

	for my $pat2 ( @{$pat1} ) {
		if (match2($pat2, $time1)) {
			return 1;
		}
	}
	return 0;
}

# type Time = ( Int, Int, Int, Int, Int )
# match_entry :: (Entry, Time) -> Boolean
sub match_entry($$) {
	my $entry = shift;
	my $time = shift;

	match1($entry->[0], $time->[0]) or return 0;
	match1($entry->[1], $time->[1]) or return 0;
	match1($entry->[2], $time->[2]) or return 0;
	match1($entry->[3], $time->[3]) or return 0;
	match1($entry->[4], $time->[4]) || ( $time->[4] == 0 && match1($entry->[4], 7)) or return 0;

	return 1;
}

my @entries;

sub load_fh($) {
	my $fh = shift;
	while (<$fh>) {
		local $current_line_no = "$.";
		my $entry = parse_line($_) or next;
		push @entries, $entry;
	}
}

sub load_file($) {
	local $current_file = shift;
	my $fh = IO::File->new($current_file) or error(IO => "cannot open $current_file");
	load_fh($fh);
}

# load crontab entries at first
if (scalar(@files)) {
	for my $file ( @files ) {
		load_file($file);
	}
} else {
	local $current_file = '<STDIN>';
	load_fh(\*STDIN);
}


# then play timeline and match to entries
my $since = time;
do {
	my @t = localtime($since);
	printf("%04d-%02d-%02d %02d:%02d:%02d NOW\n",
		$t[5] + 1900, $t[4] + 1, $t[3], $t[2], $t[1], $t[0]);
};
my $until = $since + $duration;
my $last_match = $since;
my $t0 = $since - ($since % 60); # XXX: round second to zero. is this correct...?
for (my $t = $t0; $t <= $until; $t += 60) {
	my @t = localtime($t);

	for my $entry ( @entries ) {
		if (match_entry($entry, +[
			$t[1], $t[2], $t[3], $t[4] + 1,
			$t[6],
			])
		) {
			printf(qq{%04d-%02d-%02d %02d:%02d +%d'%02d" (NOW+%d'%02d") %s %s\n},
				$t[5] + 1900, $t[4] + 1, $t[3], $t[2], $t[1],
				int(($t - $last_match) / 60), ($t - $last_match) % 60,
				int(($t - $since) / 60), ($t - $since) % 60,
				$entry->[5] ? $entry->[5] : '-', $entry->[6]);
			$last_match = $t;
		}
	}
}

do {
	my @t = localtime($until);
	printf("%04d-%02d-%02d %02d:%02d:%02d END\n",
		$t[5] + 1900, $t[4] + 1, $t[3], $t[2], $t[1], $t[0]);
};

exit(0);
