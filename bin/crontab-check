#!/usr/bin/env perl
use strict;
use utf8;

our $current_dispo;
our $current_line_no;
our $current_line_content;
our $current_file;
our $has_user = 1;

sub syntax_error($) {
	my $msg = shift;
	my $location = '';
	if ($current_file) {
		$location .= "$current_file";
	} else {
		$location .= "<STDIN>";
	}
	$location .= ":$current_line_no" if defined $current_line_no;
	$location .= ":$current_line_content" if defined ($current_line_content) && $current_line_content ne '';

	die "*** Syntax Error: $msg"
	. ($location eq '' ? '' : " at ${location}")
	. "\n";
}

# <number>|<range>|<range>/<step>|<asterisk>|<asterisk>/<step>
sub parse2($) {
	my $pat2 = shift;

	my $pat3;
	my $step;

	if ($pat2 =~ m@(.+)/([0-9]+)@) {
		$pat3 = $1;
		$step = $2;
	} else {
		$pat3 = $pat2;
		$step = undef;
	}

	! defined($step) || $step > 1 or
		syntax_error("$step is invalid step: $pat2");

	my $n;

	if ( $pat3 eq '*' ) {
		$n = '*';
	} elsif ($pat3 =~ m/^[0-9]+$/) {
		defined($step) and
			syntax_error("step is not allowed here (must be with range or *): $pat2");
		$n = $pat3;
	} elsif ($pat3 =~ m/^([0-9]+)-([0-9]+)$/) {
		$n = +[ $1, $2 ];
		$n->[0] < $n->[1] or
			syntax_error("range is reversed: " . $n->[0] . " must be less than " . $n->[1]);
	} else {
		syntax_error("number, range or * is required, but got: $pat2");
	}

	return +[ $n, $step ];
}

# comma separeted
sub parse1($$) {
	local $current_dispo = shift;
	my $pat1 = shift;
	defined($pat1) && $pat1 ne '' or
		syntax_error("$current_dispo is missing");
	$pat1 =~ m/,$/ and
		syntax_error("trailing comma is not allowed");
	return +[ map { parse2($_) } split(m/,/, $pat1) ];
}

# space separated
sub parse_line($) {
	local $current_line_content = shift;

	chomp $current_line_content or syntax_error("NO EOL");
	$current_line_content =~ s/^[ \t]*//;

	# blank line and comments are ignored
	return undef if $current_line_content eq '';
	return undef if $current_line_content =~ m/^#/;
	# variable line are also ignored
	return undef if $current_line_content =~ m/^[A-Za-z_]+ *=/;

	my ($min, $hour, $day, $month, $dow, $user, $cmd);
	if ($has_user) {
		($min, $hour, $day, $month, $dow, $user, $cmd) = split(m/[ \t]+/, $current_line_content, 7);
	} else {
		($min, $hour, $day, $month, $dow, $cmd) = split(m/[ \t]+/, $current_line_content, 6);
	}
	return +[
		parse1(min => $min),
		parse1(hour => $hour),
		parse1(day => $day),
		parse1(month => $month),
		parse1(dayofweek => $dow),
		$user, $cmd ];
}

sub match2($$) {
	my $pat2 = shift;
	my $time1 = shift;

	my ($pat3, $step) = @{$pat2};

	my $stepbase = 0;

	if (ref($pat3)) {
		# range
		$pat3->[0] <= $time1 && $time1 <= $pat3->[1] or return 0;
		$stepbase = $pat3->[0];
	} elsif ($pat3 eq '*') {
		# asterisk - always pass
	} else {
		# number
		$time1 == $pat3 or return 0;
	}

	# step check
	if (defined($step) && defined($stepbase)) {
		($stepbase % $step) == ($time1 % $step) || return 0;
	}

	return 1;
}

sub match1($$) {
	my $pat1 = shift;
	my $time1 = shift;

	for my $pat2 ( @{$pat1} ) {
		if (match2($pat2, $time1)) {
			return 1;
		}
	}
	return 0;
}

sub match_line($$) {
	my $line = shift;
	my $time = shift;

	match1($line->[0], $time->[0]) or return 0;
	match1($line->[1], $time->[1]) or return 0;
	match1($line->[2], $time->[2]) or return 0;
	match1($line->[3], $time->[3]) or return 0;
	match1($line->[4], $time->[4]) || ( $time->[4] == 0 && match1($line->[4], 7)) or return 0;

	return 1;
}

my @lines;

while (<STDIN>) {
	local $current_line_no = $.;
	push @lines, parse_line($_);
}

my $since = time;
my $until = $since + 3600 * 24 * 30;
for (my $t = $since; $t <= $until; $t += 60) {
	my @t = localtime($t);

	for my $line ( @lines ) {
		if (match_line($line, +[
			$t[1], $t[2], $t[3], $t[4] + 1,
			$t[6],
			])
		) {
			printf("%04d-%02d-%02d %02d:%02d - - %s %s\n",
				$t[5] + 1900, $t[4] + 1, $t[3], $t[2], $t[1], $line->[5] ? $line->[5] : '-', $line->[6]);
		}
	}
}
